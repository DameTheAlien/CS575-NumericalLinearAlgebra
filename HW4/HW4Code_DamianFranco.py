# -*- coding: utf-8 -*-
"""HW4Code_DamianFranco.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eCPnOs4Xk59GsYkLru_FgDUDV9C24lcY

# Homework 4
## Damian Franco
## CS-575
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing the required modules
from numpy import *
import numpy as np
import matplotlib.pyplot as plt
import time
from prettytable import PrettyTable
import scipy
import scipy.linalg 
from pprint import pprint
# %matplotlib inline
import math

# Saves the current plot to desktop since working in Google Colab
from google.colab import files
#plt.savefig("my_plot.png", bbox_inches='tight', dpi=300)
#files.download("my_plot.png")

"""# Hilbert Matrix Linear System (#4)"""

# Test out 3x3 hilbert matrix A
test_hilb = scipy.linalg.hilbert(3)
pprint(test_hilb)

# Test out 3x1 vector b
print(test_hilb.sum(axis=1))

# Digits of accuracy
dList_4 = []

# Initialize all lists of precision testing
n_arr = [8, 9, 10, 11, 12]
estimatedList = []
condList = []
errList = []
resdList = []

# Parse through all hilbert matrices and save metrics
for curr_n in n_arr:
  # Initialize current system
  curr_hilb = scipy.linalg.hilbert(curr_n)
  curr_b = curr_hilb.sum(axis=1)
  curr_exact = np.ones(curr_n)
  # Calculate cond(Hilb)
  curr_cond = np.linalg.cond(curr_hilb)
  condList.append(curr_cond)
  # Evaluate current degree of accuracy
  currDeg = abs(np.log10(np.finfo(float).eps)) - np.log10(curr_cond)
  dList_4.append(currDeg)
  # Solve the system
  curr_x = scipy.linalg.solve(curr_hilb, curr_b)
  estimatedList.append(curr_x)
  # Calculate error
  curr_err = np.linalg.norm(np.subtract(curr_x, curr_exact), 2) / np.linalg.norm(curr_exact, 2)
  errList.append(curr_err)
  # Calculate residual
  curr_resd = np.linalg.norm(np.subtract(curr_b, np.matmul(curr_hilb, curr_x)), 2) / np.linalg.norm(curr_b, 2)
  resdList.append(curr_resd)

print(dList_4)

print(condList)

pprint(estimatedList)

# Print out solution of each matrix with 16 digits as shown
acc = 0
for lst in estimatedList:
  print('Solution Hilbert N =', n_arr[acc])
  print('[')
  for elm in lst:
    print(elm, ',')
  print(']\n')
  acc += 1

print(condList)

# Create condition number table with sizes
myTable = PrettyTable(["N size", "Digits of Accuracy", "Digits Ceiling"])

ceilAcc = []
roundedAcc = []
for i in range(len(n_arr)):
  currD = dList_4[i] + 1
  roundedAcc.append(currD)
  currRound = ceil(currD)
  ceilAcc.append(currRound)

# Add rows
for i in range(len(n_arr)):
  myTable.add_row([n_arr[i], roundedAcc[i], ceilAcc[i]])

print(myTable)

# Create condition number table with sizes
myTable = PrettyTable(["N size", "Condition Number"])

# Add rows
for i in range(len(n_arr)):
  myTable.add_row([n_arr[i], condList[i]])

print(myTable)

# Create error table with sizes
myTable = PrettyTable(["N size", "Relative Error", "Relative Residual"])

# Add rows
for i in range(len(n_arr)):
  myTable.add_row([n_arr[i], errList[i], resdList[i]])

print(myTable)

"""# Loss of Precision (#6)"""

# Intialize x
x = 1.2e-8
nonsci_x = f"{x:.9f}"
print(nonsci_x)

cos_sub = 1 - math.cos(x)
print(math.cos(x))

half_ang = 1 - 2*(math.sin(x/2))**2
print((1 - 2*(math.sin(x/2))**2))

# Calculate number of accurate digits -log10(ε/|x-y|)
d_cos = -np.log10((np.finfo(float).eps) / (abs(cos_sub)))
print(d_cos)

# Calculate number of accurate digits -log10(ε/|x-y|)
d_half = -np.log10((np.finfo(float).eps) / (abs(half_ang)))
print(d_half)

# Evaluate the given f(x) function
eval = (1 - math.cos(x)) / ((x)**2)
print(eval)

# Evaluate same f(x) function but with the half angle formula
eval_halfAngle = (1 - (1 - 2*(math.sin(x/2))**2)) / ((x)**2)
print(eval_halfAngle)