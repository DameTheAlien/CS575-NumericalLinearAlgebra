# -*- coding: utf-8 -*-
"""HW9Code_DamianFranco.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SDlPwbLEo9goGIY_Iv1fMI_lTTQpKa-B

# Homework 9
## Damian Franco
## CS-575

This program has two parts to the code. The first is setting up a matrix A and finding the iteration matrix and properties of the matrix to determine if the matrix will converge using Gauss-Seidel's algorithm. The next section (Question 3) is an implementation of Jacobi's and Gauss-Seidels algorithms to solve a linear system Ax = b with some examples and tables of my findings.
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing the required modules
from numpy import *
import numpy as np
import matplotlib.pyplot as plt
import time
from prettytable import PrettyTable
import scipy
import scipy.linalg 
from pprint import pprint
# %matplotlib inline
import math

# Saves the current plot to desktop since working in Google Colab
from google.colab import files
#plt.savefig("my_plot.png", bbox_inches='tight', dpi=300)
#files.download("my_plot.png")

"""# Question 2"""

# Set up matrix A
A_GS = np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 2]])
A_GS

"""## Check if A is invertible"""

# Compute the determinant of A
det_A_GS = np.linalg.det(A_GS)

if det_A_GS != 0:
    print("A is invertible")
else:
    print("A is not invertible")

"""## Find the iteration matrix M"""

# Compute the iteration matrix
D = np.diag(np.diag(A_GS)) 
L = np.tril(A_GS, -1)
U = np.triu(A_GS, 1)
M_GS = np.linalg.inv(D - L) @ U
print(M_GS)

"""## Find spectral radius p(M) of M """

# Compute the eigenvalues and p(M)
eigVals = np.linalg.eigvals(M_GS)
spectral_radius = np.max(np.abs(eigVals))
print("Spectral radius =", spectral_radius)

"""## Find norms of M"""

# 1-norm
one_norm = np.linalg.norm(M_GS, ord=1)
print("1-norm =", one_norm)

# 2-norm
two_norm = np.linalg.norm(M_GS, ord=2)
print("2-norm =", two_norm)

# Infinity norm
inf_norm = np.linalg.norm(M_GS, ord=np.inf)
print("Infinity norm =", inf_norm)

"""# Question 3

## Form sparse linear system
"""

f = lambda x: 4 * np.pi**2 * np.sin(2 * np.pi * x)

def form_sparse_lin_sys(N):
    # Form matrix A
    A = scipy.sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(N, N))
    
    # Form vector b
    h = 1/(N+1)
    b = np.zeros((N,))
    for i in range(N):
        b[i] = h**2 * f( (i+1)*h )

    return A, b

# Testing out functionality of the function
N_test = 10
A_test, b_test = form_sparse_lin_sys(N_test)
A_test

# Printing out non-sparse version of the sparse matrix generated, just for testing
# A.toarray()

b_test

"""## Solving the system with SciPy"""

x_star = scipy.sparse.linalg.spsolve(A_test, b_test)
x_star

"""## Check if matrix is strictly diagonally dominant"""

def strictDiagDom(A):
  # Check if input matrix A is strictly diagonally dominant
    if not scipy.sparse.isspmatrix(A):
        print("Input matrix is not a sparse matrix")
        return False
    
    diag = np.abs(A.diagonal())
    off_diag = np.abs(A.sum(axis=1) - diag)
    isDom = np.all(diag > off_diag)
    
    if isDom:
        print("A is strictly diagonally dominant")
    else:
        print("A is not strictly diagonally dominant")
        
    return isDom

"""## Jacobi Method for solving Ax = b"""

def jacobi(A, b, n, max_iter):
    # Define tolerance for error
    tol = 1e-10

    # Check if input matrix A is strictly diagonally dominant
    if not strictDiagDom(A):
        print('A is not strictly diagonally dominant, may not converge')

    # Convert A to CSR format
    A = scipy.sparse.csr_matrix(A)
    x = np.zeros_like(n)
    x_star = scipy.sparse.linalg.spsolve(A, b)

    for i in range(max_iter):
        # Compute residual
        r = b - A.dot(x)
        D = A.diagonal()

        # Compute the Jacobi update
        delta = np.divide(r, D)
        x_new = x + delta

        # Check for convergence
        if np.linalg.norm(delta) < tol:
            break

        x = x_new

    # Compute iteration matrix and spectral radius
    M = scipy.sparse.diags(1/D, 0).dot(A)
    spectral_radius = np.abs(scipy.sparse.linalg.eigs(M, k=1, return_eigenvectors=False))[0]

    # Compute the error
    err_st1 = abs(x_star - x)
    err = scipy.linalg.norm(err_st1)

    return x, spectral_radius, err

jac_estimate, jac_specRad, jac_error = jacobi(A_test, b_test, N_test, 1000)
jac_estimate

x_star

"""## Gauss-Seidel Method for Solving Ax = b"""

def gaussSeidel(A, b, n, max_iter):
    # Define tolerance for error
    tol = 1e-10

    # Check if input matrix A is strictly diagonally dominant
    if not strictDiagDom(A):
        print('A is not strictly diagonally dominant, may not converge')
    
    # Convert A to CSR format
    A = scipy.sparse.csr_matrix(A)
    x = np.zeros(n)
    x_star = scipy.sparse.linalg.spsolve(A, b)

    for i in range(max_iter):
        for j in range(n):
            # Compute the residual for the jth equation
            r_j = b[j] - A[j,:].dot(x)
            D_jj = A[j,j]

            # Compute the Gauss-Seidel update for the jth variable
            x[j] += r_j / D_jj

        # Check for convergence
        if np.linalg.norm(r_j) < tol:
            break

    # Compute iteration matrix and spectral radius
    M = scipy.sparse.tril(A, k=-1).dot(scipy.sparse.linalg.spsolve(scipy.sparse.triu(A, k=0), scipy.sparse.eye(n)))
    spectral_radius = np.abs(scipy.sparse.linalg.eigs(M, k=1, return_eigenvectors=False))[0]

    # Compute the error
    err_st1 = abs(x_star - x)
    err = scipy.linalg.norm(err_st1)

    return x, spectral_radius, err

gauss_estimate, gauss_specRad, gauss_error = gaussSeidel(A_test, b_test, N_test, 1000)
gauss_estimate

x_star

"""## Testing out with different matrices"""

N_sizes = [10, 20, 40, 80, 160]
for i in N_sizes:
  A_curr, b_curr = form_sparse_lin_sys(i)
  x_star_curr = scipy.sparse.linalg.spsolve(A_curr, b_curr)
  jac_estimate, jac_specRad, jac_error = jacobi(A_curr, b_curr, i, 1000)
  gauss_estimate, gauss_specRad, gauss_error= gaussSeidel(A_curr, b_curr, i, 1000)

  print('Current Matrix Size N:', i) 
  print(jac_estimate)
  print(gauss_estimate)
  print('Jacobi Method Spectral Radius:', jac_specRad)
  print('Gauss-Seidel Spectral Radius:', gauss_specRad)
  print('')

"""## Check iterations"""

N_iter = 100
A_iter, b_iter = form_sparse_lin_sys(N_iter)
x_star_iter = scipy.sparse.linalg.spsolve(A_iter, b_iter)

jac_errors_iters = []
gauss_errors_iters = []

jac_specrad_iters = []
gauss_specrad_iters = []

current_iter = 100
# Jacobi Testing
jac_estimate, jac_specRad, jac_error = jacobi(A_iter, b_iter, N_iter, current_iter)
jac_errors_iters.append(jac_error)
jac_specrad_iters.append(jac_specRad)
# Gauss-Seidel Testing
gauss_estimate, gauss_specRad, gauss_error = gaussSeidel(A_iter, b_iter, N_iter, current_iter)
gauss_errors_iters.append(gauss_error)
gauss_specrad_iters.append(gauss_specRad)

jac_errors_iters

gauss_errors_iters

jac_specrad_iters

gauss_specrad_iters

jac_nk_errors = []
gauss_nk_errors = []

for curr in range(len(gauss_errors_iters)):
    jac_curr_nk = jac_errors_iters[curr] / jac_errors_iters[0]
    jac_nk_errors.append(jac_curr_nk)
    gauss_curr_nk = gauss_errors_iters[curr] / gauss_errors_iters[0]
    gauss_nk_errors.append(gauss_curr_nk)

# Create error table with sizes
# Specify the Column Names while initializing the Table
myTable_sr = PrettyTable(["Iteration", "Jacobi Spectral Radius", "Gauss-Seidel Spectral Radius"])
iterNum_sr = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
# Add rows
for i in range(0,10):
  myTable_sr.add_row([iterNum_sr[i], jac_specrad_iters[i], gauss_specrad_iters[i]])

print(myTable_sr)

# Create error table with sizes
# Specify the Column Names while initializing the Table
myTable = PrettyTable(["Iteration", "Jacobi Absolute Error", "Gauss-Seidel Absolute Error", "Jacobi Relative Error", "Gauss-Seidel Relative Error"])
iterNum = [1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
# Add rows
for i in range(0,10):
  myTable.add_row([iterNum[i], jac_errors_iters[i], gauss_errors_iters[i], jac_nk_errors[i], gauss_nk_errors[i]])

print(myTable)