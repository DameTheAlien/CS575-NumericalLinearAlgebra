# -*- coding: utf-8 -*-
"""HW3_DamianFranco.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OU4XH0QUAqS7DOij9gS8fnFGCSPtBmua

# Homework 3
## Damian Franco
## CS-575
"""

# Commented out IPython magic to ensure Python compatibility.
# Importing the required modules
from numpy import *
import numpy as np
import matplotlib.pyplot as plt
import time
from prettytable import PrettyTable
import scipy
import scipy.linalg 
# %matplotlib inline

# Saves the current plot to desktop since working in Google Colab
from google.colab import files
#plt.savefig("my_plot.png", bbox_inches='tight', dpi=300)
#files.download("my_plot.png")

"""# GE without pivoting (GE) Banded Matrix"""

# Forward elimination
def forward(A, b):
  n = len(b)

  for k in range(n-1):
    # print('k:', k)
    for i in range(k+1, n):
      # print('i:', i)
      xmult = A[i][k] / A[k][k]
      # for j in range(k, n):
      for j in range(k, n):
        # print('j:', j)
        # print('k:', k, 'i:', i, 'j:', j)
        # print(A[k][j])
        A[i][j] = A[i][j] - xmult * A[k][j] 
      b[i] = b[i] - xmult * b[k]

  return A, b

def forward_tri(A, b):
    n = len(b)
    for k in range(n-1):
        xmult = A[k+1][k] / A[k][k]
        A[k+1][k+1] = A[k+1][k+1] - xmult * A[k][k+1]
        b[k+1] = b[k+1] - xmult * b[k]
    for k in range(n):
        for i in range(max(0, k-1), min(n, k+2)):
            if i != k+1:
                continue
            xmult = A[i][k] / A[k][k]
            for j in range(max(0, k-1), min(n, k+2)):
                if j != k and j != i:
                    continue
                A[i][j] = A[i][j] - xmult * A[k][j]
            b[i] = b[i] - xmult * b[k]
    return A, b

# Backward substitution
def back(U, b):
  n = len(b)
  x = np.zeros(n)
    
  x[n-1] = b[n-1] / U[n-1, n-1]
  for i in range(n-2, -1, -1):
    s = b[i]
    for j in range(i+1, n):
      s = s - U[i][j] * x[j]
    x[i] = s / U[i][i]

  return x

def GE(A,b):
  forA, forb = forward_tri(A, b)
  # print(forA)
  # print(forb)
  x = back(forA, forb)
  return x

def create_tri_mat(N):
  A_tri= np.zeros((N,3))
  A_tri[1:N,0] = -2*np.ones((N-1,)) #sub-diagonal
  A_tri[0:N,1] =  10*np.ones((N,))   #diagonal
  A_tri[0:N-1,2] = -4*np.ones((N-1,))   #super-diagonal
  return A_tri

def create_dense_mat(A_tri,N):
  A_dense = np.zeros((N,N))
  for i in range(N): # go over all rows
    # only 3 non-zero entries in each row.
    for j in range(i-1,i+2):  #This will go through entries (i,i-1), (i,i) and (i,i+1)
      if j >= 0 and j <= N-1:
        A_dense[i,j] = A_tri[i,j-i+1] #Make sure you understand the indexing
  return A_dense

N = 6
A_tri = create_tri_mat(N)
print(A_tri)

A_dense = create_dense_mat(A_tri, N)
print(A_dense)

b = np.ones(N)
print(b)

exact = np.linalg.solve(A_dense, b)
print(exact)

returnA, returnb = forward(A_dense, b)
print(returnA)

print(returnb)

returnAtri, returnbtri = forward_tri(A_dense, b)
print(returnAtri)

print(returnbtri)

approxxtri = back(returnAtri, returnbtri)
print(approxxtri)

aprroxGE = GE(A_dense, b)
print("My approximation:", aprroxGE)
print("Exact solution:", exact)

num2_error = []
for i in range(len(b)):
  num2_error.append(abs(exact[i]-aprroxGE[i]))
print(num2_error)

# This set of N values should generally work well for most machines for Mat-vec
# Changed this to fit more appropiatly with some tests on my machine
# N_arr = np.array([20, 40, 80, 160]) 
N_arr = [100,200,300,400,500,600,700,800,1000]
time_list = []
err_list = []
for curr_N in N_arr:
  # Generate random vectors and matrices
  A_curr_tri = create_tri_mat(curr_N)
  A_ge = create_dense_mat(A_curr_tri, curr_N)
  b_ge = np.ones(curr_N)
    
  if (np.linalg.det(A_ge) != 0):
    print("Non Singular matrix")
    t_start = time.time()
    x_mine = GE(A_ge, b_ge)
    t_end = time.time()
    
    #Verification
    x_true = np.linalg.solve(A_ge, b_ge)
    err_list.append(np.linalg.norm(x_mine - x_true))
    
    time_list.append(t_end-t_start)
  else:
    print("Singular Matrix")

print(x_true)
print(x_mine)

# Create error table with sizes
# Specify the Column Names while initializing the Table
myTable = PrettyTable(["N size", "Runtime Speed (sec)", "Error"])

# Add rows
for i in range(len(N_arr)):
  myTable.add_row([N_arr[i], time_list[i], err_list[i]])

print(myTable)

# Plot the runtime results
plt.loglog(N_arr, time_list, label='GE Runtime')
plt.xlabel('$N$')
plt.ylabel('$Time$')

# Plotting the x^2 asymptotic bound
x_cords = range(N_arr[0], N_arr[len(N_arr)-1])
y_cords = [x*x*1e-5 for x in x_cords]
plt.plot(x_cords, y_cords, label='O(n)')

plt.legend(loc="upper left")
plt.title('Banded GE without Partial Pivoting Runtime Analysis')

# plt.savefig("my_plot.png", bbox_inches='tight', dpi=300)
# files.download("my_plot.png")
plt.show()